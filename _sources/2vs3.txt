************************
Porównanie Pythona 2 i 3
************************

Funkcja ``print``
=================

Zastąpiono słowo kluczowe funkcją:

.. code-block:: python

    #Python 2

    print 'Python', python_version()
    print 'Hello, World!'
    print('Hello, World!')
    print "text", ; print 'print more text on the same line'

.. code-block:: bash

    Python 2.7.6
    Hello, World!
    Hello, World!
    text print more text on the same line

.. code-block:: python

    #Python 3

    print('Python', python_version())
    print('Hello, World!')

    print("some text,", end="")
    print(' print more text on the same line')

.. code-block:: bash

    Python 3.4.1
    Hello, World!
    some text, print more text on the same line

.. code-block:: python

    print 'Hello, World!'

.. code-block:: bash

    File "", line 1
        print 'Hello, World!'
                                ^
    SyntaxError: invalid syntax


Dzielenie
=========

.. code-block:: python

    #Python 2

    print 'Python', python_version()
    print '3 / 2 =', 3 / 2
    print '3 // 2 =', 3 // 2
    print '3 / 2.0 =', 3 / 2.0
    print '3 // 2.0 =', 3 // 2.0

.. code-block:: bash

    Python 2.7.6
    3 / 2 = 1
    3 // 2 = 1
    3 / 2.0 = 1.5
    3 // 2.0 = 1.0


.. code-block:: python

    #Python 3

    print('Python', python_version())
    print('3 / 2 =', 3 / 2)
    print('3 // 2 =', 3 // 2)
    print('3 / 2.0 =', 3 / 2.0)
    print('3 // 2.0 =', 3 // 2.0)

.. code-block:: bash

    Python 3.4.1
    3 / 2 = 1.5
    3 // 2 = 1
    3 / 2.0 = 1.5
    3 // 2.0 = 1.0


Wsparcie dla Unicode
====================

Python 2 has ASCII str() types, separate unicode(), but no byte type.

Now, in Python 3, we finally have Unicode (utf-8) strings, and 2 byte classes: byte and bytearrays.


Python 2

print 'Python', python_version()

Python 2.7.6

print type(unicode('this is like a python3 str type'))

<type 'unicode'>

print type(b'byte type does not exist')

<type 'str'>

print 'they are really' + b' the same'

they are really the same

print type(bytearray(b'bytearray oddly does exist though'))

<type 'bytearray'>


Python 3

print('Python', python_version())
print('strings are now utf-8 \u03BCnico\u0394é!')

Python 3.4.1
strings are now utf-8 μnicoΔé!

print('Python', python_version(), end="")
print(' has', type(b' bytes for storing data'))

Python 3.4.1 has <class 'bytes'>

print('and Python', python_version(), end="")
print(' also has', type(bytearray(b'bytearrays')))

and Python 3.4.1 also has <class 'bytearray'>

'note that we cannot add a string' + b'bytes for data'

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
 in ()
----> 1 'note that we cannot add a string' + b'bytes for data'

TypeError: Can't convert 'bytes' object to str implicitly



xrange
[back to top]

The usage of xrange() is very popular in Python 2.x for creating an iterable object, e.g., in a for-loop or list/set-dictionary-comprehension.\ The behavior was quite similar to a generator (i.e., "lazy evaluation"), but here the xrange-iterable is not exhaustible - meaning, you could iterate over it infinitely.

Thanks to its "lazy-evaluation", the advantage of the regular range() is that xrange() is generally faster if you have to iterate over it only once (e.g., in a for-loop). However, in contrast to 1-time iterations, it is not recommended if you repeat the iteration multiple times, since the generation happens every time from scratch!

In Python 3, the range() was implemented like the xrange() function so that a dedicated xrange() function does not exist anymore (xrange() raises a NameError in Python 3).

import timeit

n = 10000
def test_range(n):
    for i in range(n):
        pass

def test_xrange(n):
    for i in xrange(n):
        pass


Python 2

print 'Python', python_version()

print '\ntiming range()'
%timeit test_range(n)

print '\n\ntiming xrange()'
%timeit test_xrange(n)

Python 2.7.6

timing range()
1000 loops, best of 3: 433 µs per loop


timing xrange()
1000 loops, best of 3: 350 µs per loop


Python 3

print('Python', python_version())

print('\ntiming range()')
%timeit test_range(n)

Python 3.4.1

timing range()
1000 loops, best of 3: 520 µs per loop

print(xrange(10))

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
 in ()
----> 1 print(xrange(10))

NameError: name 'xrange' is not defined

The __contains__ method for range objects in Python 3

Another thing worth mentioning is that range got a "new" __contains__ method in Python 3.x (thanks to Yuchen Ying, who pointed this out). The __contains__ method can speedup "look-ups" in Python 3.x range significantly for integer and Boolean types.

x = 10000000

def val_in_range(x, val):
return val in range(x)

def val_in_xrange(x, val):
    return val in xrange(x)

print('Python', python_version())
assert(val_in_range(x, x/2) == True)
assert(val_in_range(x, x//2) == True)
%timeit val_in_range(x, x/2)
%timeit val_in_range(x, x//2)

Python 3.4.1
1 loops, best of 3: 742 ms per loop
1000000 loops, best of 3: 1.19 µs per loop

Based on the timeit results above, you see that the execution for the "look up" was about 60,000 faster when it was of an integer type rather than a float. However, since Python 2.x's range or xrange doesn't have a __contains__ method, the "look-up speed" wouldn't be that much different for integers or floats:

print 'Python', python_version()
assert(val_in_xrange(x, x/2.0) == True)
assert(val_in_xrange(x, x/2) == True)
assert(val_in_range(x, x/2) == True)
assert(val_in_range(x, x//2) == True)
%timeit val_in_xrange(x, x/2.0)
%timeit val_in_xrange(x, x/2)
%timeit val_in_range(x, x/2.0)
%timeit val_in_range(x, x/2)

Python 2.7.7
1 loops, best of 3: 285 ms per loop
1 loops, best of 3: 179 ms per loop
1 loops, best of 3: 658 ms per loop
1 loops, best of 3: 556 ms per loop


Below the "proofs" that the __contain__ method wasn't added to Python 2.x yet:

print('Python', python_version())
range.__contains__

Python 3.4.1
<slot wrapper '__contains__' of 'range' objects>

print 'Python', python_version()
range.__contains__

Python 2.7.7
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
 in ()
      1 print 'Python', python_version()
----> 2 range.__contains__

AttributeError: 'builtin_function_or_method' object has no attribute '__contains__'

print 'Python', python_version()
xrange.__contains__

Python 2.7.7
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
 in ()
      1 print 'Python', python_version()
----> 2 xrange.__contains__

AttributeError: type object 'xrange' has no attribute '__contains__'


Note about the speed differences in Python 2 and 3

Some people pointed out the speed difference between Python 3's range() and Python2's xrange(). Since they are implemented the same way one would expect the same speed. However the difference here just comes from the fact that Python 3 generally tends to run slower than Python 2.

def test_while():
    i = 0
    while i < 20000:
        i += 1
    return


print('Python', python_version())
%timeit test_while()

Python 3.4.1
100 loops, best of 3: 2.68 ms per loop

print 'Python', python_version()
%timeit test_while()

Python 2.7.6
1000 loops, best of 3: 1.72 ms per loop



Raising exceptions
[back to top]

Where Python 2 accepts both notations, the 'old' and the 'new' syntax, Python 3 chokes (and raises a SyntaxError in turn) if we don't enclose the exception argument in parentheses:


Python 2

print 'Python', python_version()

Python 2.7.6

raise IOError, "file error"

---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
 in ()
----> 1 raise IOError, "file error"

IOError: file error

raise IOError("file error")

---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
 in ()
----> 1 raise IOError("file error")

IOError: file error


Python 3

print('Python', python_version())

Python 3.4.1

raise IOError, "file error"

File "", line 1
raise IOError, "file error"
                     ^
SyntaxError: invalid syntax

The proper way to raise an exception in Python 3:

print('Python', python_version())
raise IOError("file error")

Python 3.4.1

---------------------------------------------------------------------------
OSError                                   Traceback (most recent call last)
 in ()
      1 print('Python', python_version())
----> 2 raise IOError("file error")

OSError: file error



Handling exceptions
[back to top]

Also the handling of exceptions has slightly changed in Python 3. In Python 3 we have to use the "as" keyword now


Python 2

print 'Python', python_version()
try:
    let_us_cause_a_NameError
except NameError, err:
    print err, '--> our error message'

Python 2.7.6
name 'let_us_cause_a_NameError' is not defined --> our error message


Python 3

print('Python', python_version())
try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, '--> our error message')

Python 3.4.1
name 'let_us_cause_a_NameError' is not defined --> our error message



The next() function and .next() method
[back to top]

Since next() (.next()) is such a commonly used function (method), this is another syntax change (or rather change in implementation) that is worth mentioning: where you can use both the function and method syntax in Python 2.7.5, the next() function is all that remains in Python 3 (calling the .next() method raises an AttributeError).


Python 2

print 'Python', python_version()

my_generator = (letter for letter in 'abcdefg')

next(my_generator)
my_generator.next()

Python 2.7.6
'b'


Python 3

print('Python', python_version())

my_generator = (letter for letter in 'abcdefg')

next(my_generator)

Python 3.4.1
'a'

my_generator.next()

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
 in ()
----> 1 my_generator.next()

AttributeError: 'generator' object has no attribute 'next'



For-loop variables and the global namespace leak
[back to top]

Good news is: In Python 3.x for-loop variables don't leak into the global namespace anymore!

This goes back to a change that was made in Python 3.x and is described in What’s New In Python 3.0 as follows:

"List comprehensions no longer support the syntactic form [... for var in item1, item2, ...]. Use [... for var in (item1, item2, ...)] instead. Also note that list comprehensions have different semantics: they are closer to syntactic sugar for a generator expression inside a list() constructor, and in particular the loop control variables are no longer leaked into the surrounding scope."


Python 2

print 'Python', python_version()

i = 1
print 'before: i =', i

print 'comprehension: ', [i for i in range(5)]

print 'after: i =', i

Python 2.7.6
before: i = 1
comprehension:  [0, 1, 2, 3, 4]
after: i = 4


Python 3

print('Python', python_version())

i = 1
print('before: i =', i)

print('comprehension:', [i for i in range(5)])

print('after: i =', i)

Python 3.4.1
before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1



Comparing unorderable types
[back to top]

Another nice change in Python 3 is that a TypeError is raised as warning if we try to compare unorderable types.


Python 2

print 'Python', python_version()
print "[1, 2] > 'foo' = ", [1, 2] > 'foo'
print "(1, 2) > 'foo' = ", (1, 2) > 'foo'
print "[1, 2] > (1, 2) = ", [1, 2] > (1, 2)

Python 2.7.6
[1, 2] > 'foo' =  False
(1, 2) > 'foo' =  True
[1, 2] > (1, 2) =  False


Python 3

print('Python', python_version())
print("[1, 2] > 'foo' = ", [1, 2] > 'foo')
print("(1, 2) > 'foo' = ", (1, 2) > 'foo')
print("[1, 2] > (1, 2) = ", [1, 2] > (1, 2))

Python 3.4.1

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
 in ()
      1 print('Python', python_version())
----> 2 print("[1, 2] > 'foo' = ", [1, 2] > 'foo')
      3 print("(1, 2) > 'foo' = ", (1, 2) > 'foo')
      4 print("[1, 2] > (1, 2) = ", [1, 2] > (1, 2))

TypeError: unorderable types: list() > str()



Parsing user inputs via input()
[back to top]

Fortunately, the input() function was fixed in Python 3 so that it always stores the user inputs as str objects. In order to avoid the dangerous behavior in Python 2 to read in other types than strings, we have to use raw_input() instead.


Python 2

Python 2.7.6
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type "help", "copyright", "credits" or "license" for more information.

>>> my_input = input('enter a number: ')

enter a number: 123

>>> type(my_input)
<type 'int'>

>>> my_input = raw_input('enter a number: ')

enter a number: 123

type(my_input)
<type 'str'>


Python 3

Python 3.4.1
[GCC 4.2.1 (Apple Inc. build 5577)] on darwin
Type "help", "copyright", "credits" or "license" for more information.

>>> my_input = input('enter a number: ')

enter a number: 123

>>> type(my_input)
<class 'str'>



Returning iterable objects instead of lists
[back to top]

As we have already seen in the xrange section, some functions and methods return iterable objects in Python 3 now - instead of lists in Python 2.

Since we usually iterate over those only once anyway, I think this change makes a lot of sense to save memory. However, it is also possible - in contrast to generators - to iterate over those multiple times if needed, it is aonly not so efficient.

And for those cases where we really need the list-objects, we can simply convert the iterable object into a list via the list() function.


Python 2

print 'Python', python_version()

print range(3)
print type(range(3))

Python 2.7.6
[0, 1, 2]
<type 'list'>


Python 3

print('Python', python_version())

print(range(3))
print(type(range(3)))
print(list(range(3)))

Python 3.4.1
range(0, 3)
<class 'range'>
[0, 1, 2]

Some more commonly used functions and methods that don't return lists anymore in Python 3:

    zip()

    map()

    filter()

    dictionary's .keys() method

    dictionary's .values() method

    dictionary's .items() method



More articles about Python 2 and Python 3
[back to top]

Here is a list of some good articles concerning Python 2 and 3 that I would recommend as a follow-up.

// Porting to Python 3

    Should I use Python 2 or Python 3 for my development activity?
    What’s New In Python 3.0
    Porting to Python 3
    Porting Python 2 Code to Python 3
    How keep Python 3 moving forward

// Pro and anti Python 3

    10 awesome features of Python that you can't use because you refuse to upgrade to Python 3
    Everything you did not want to know about Unicode in Python 3
    Python 3 is killing Python
    Python 3 can revive Python
    Python 3 is fine

© 2013-present Sebastian Raschka |@rasbt email rss
